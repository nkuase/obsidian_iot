/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  choseFilterSet: () => choseFilterSet,
  default: () => FnOPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian5 = require("obsidian");

// src/settings.ts
var import_obsidian3 = require("obsidian");

// src/UI/GenericInputPrompt.ts
var import_obsidian = require("obsidian");
var GenericInputPrompt = class extends import_obsidian.Modal {
  constructor(app2, header, placeholder, value, required, validator) {
    super(app2);
    this.header = header;
    this.didSubmit = false;
    this.submitClickCallback = (evt) => this.submit();
    this.cancelClickCallback = (evt) => this.cancel();
    this.submitEnterCallback = (evt) => {
      if (!evt.isComposing && evt.key === "Enter") {
        evt.preventDefault();
        this.submit();
      }
    };
    this.header = header;
    this.placeholder = placeholder != null ? placeholder : "";
    this.input = value != null ? value : "";
    this.required = required != null ? required : false;
    this.validator = validator;
    this.waitForClose = new Promise((resolve, reject) => {
      this.resolvePromise = resolve;
      this.rejectPromise = reject;
    });
    this.display();
    this.open();
  }
  static Prompt(app2, header, placeholder, value, required, validator) {
    const newPromptModal = new GenericInputPrompt(app2, header, placeholder, value, required, validator);
    return newPromptModal.waitForClose;
  }
  display() {
    this.contentEl.empty();
    this.titleEl.textContent = this.header;
    if (this.required) {
      this.titleEl.addClass("requiredInputHeader");
    }
    const mainContentContainer = this.contentEl.createDiv();
    this.inputComponent = this.createInputField(mainContentContainer, this.placeholder, this.input);
    this.createButtonBar(mainContentContainer);
  }
  createInputField(container, placeholder, value) {
    const textComponent = new import_obsidian.TextComponent(container);
    textComponent.inputEl.classList.add("text-input");
    textComponent.setPlaceholder(placeholder != null ? placeholder : "").setValue((value || "").toString()).onChange((value2) => {
      this.input = value2;
      this.updateInputValidation(textComponent, value2);
    }).inputEl.addEventListener("keydown", this.submitEnterCallback);
    this.updateInputValidation(textComponent, value || "");
    return textComponent;
  }
  updateInputValidation(textComponent, value) {
    if (this.validator) {
      if (this.validator(value, false)) {
        textComponent.inputEl.removeClass("requiredInput");
      } else {
        textComponent.inputEl.addClass("requiredInput");
      }
    }
  }
  createButton(container, text, callback) {
    const btn = new import_obsidian.ButtonComponent(container);
    btn.setButtonText(text).onClick(callback);
    return btn;
  }
  createButtonBar(mainContentContainer) {
    const buttonBarContainer = mainContentContainer.createDiv();
    this.createButton(buttonBarContainer, "Ok", this.submitClickCallback).setCta().buttonEl.classList.add("ok-button");
    this.createButton(buttonBarContainer, "Cancel", this.cancelClickCallback);
    buttonBarContainer.classList.add("button-bar");
  }
  submit() {
    if (this.validator && !this.validator(this.input, true)) {
      if (this.required)
        return;
      else {
        this.input = "";
      }
    }
    this.didSubmit = true;
    this.close();
  }
  cancel() {
    this.close();
  }
  resolveInput() {
    if (!this.didSubmit)
      this.rejectPromise("No input given.");
    else
      this.resolvePromise(this.input);
  }
  removeInputListener() {
    this.inputComponent.inputEl.removeEventListener("keydown", this.submitEnterCallback);
  }
  onOpen() {
    super.onOpen();
    this.inputComponent.inputEl.focus();
    this.inputComponent.inputEl.select();
  }
  onClose() {
    super.onClose();
    this.resolveInput();
    this.removeInputListener();
  }
};

// src/UI/BoolInputPrompt.ts
var import_obsidian2 = require("obsidian");
var BoolInputPrompt = class extends import_obsidian2.Modal {
  constructor(app2, header) {
    super(app2);
    this.header = header;
    this.didSubmit = false;
    this.submitClickCallback = (evt) => this.submit();
    this.cancelClickCallback = (evt) => this.cancel();
    this.waitForClose = new Promise((resolve, reject) => {
      this.resolvePromise = resolve;
    });
    this.display();
    this.open();
  }
  static Prompt(app2, header) {
    const newPromptModal = new BoolInputPrompt(app2, header);
    return newPromptModal.waitForClose;
  }
  display() {
    this.contentEl.empty();
    this.titleEl.textContent = this.header;
    const mainContentContainer = this.contentEl.createDiv();
    this.createButtonBar(mainContentContainer);
  }
  createButton(container, text, callback) {
    const btn = new import_obsidian2.ButtonComponent(container);
    btn.setButtonText(text).onClick(callback);
    return btn;
  }
  createButtonBar(mainContentContainer) {
    const buttonBarContainer = mainContentContainer.createDiv();
    this.createButton(buttonBarContainer, "Ok", this.submitClickCallback).setCta().buttonEl.classList.add("ok-button");
    this.createButton(buttonBarContainer, "Cancel", this.cancelClickCallback);
    buttonBarContainer.classList.add("button-bar");
  }
  submit() {
    this.didSubmit = true;
    this.close();
  }
  cancel() {
    this.close();
  }
  onOpen() {
    super.onOpen();
  }
  onClose() {
    super.onClose();
    this.resolvePromise(this.didSubmit);
  }
};

// src/settings.ts
var DEFAULT_NOTE_FILTER_SET = {
  name: "default",
  excludeNoteName: "",
  excludePathName: "",
  includeNoteName: "",
  includePathName: "",
  includeTags: "",
  excludeTags: ""
};
var DEFAULT_FOLDER_FILTER_SET = {
  name: "default",
  rootFolder: "/",
  includeParents: false,
  depth: 1,
  excludeFolderName: "",
  excludePathName: "",
  includeFolderName: "",
  includePathName: ""
};
var DEFAULT_SETTINGS = {
  pickerIndex: 0,
  noteFilterSets: [DEFAULT_NOTE_FILTER_SET],
  folderFilterSets: [DEFAULT_FOLDER_FILTER_SET]
};
var FNOSettingTab = class extends import_obsidian3.PluginSettingTab {
  constructor(app2, plugin) {
    super(app2, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl, plugin: { settings } } = this;
    containerEl.empty();
    new import_obsidian3.Setting(containerEl).setName("Picker mode").setDesc("Picker types: " + this.plugin.pickers.map((p) => `${p.name}: ${p.description}`).join(", ")).addDropdown((dropdown) => {
      this.plugin.pickers.forEach((picker, index) => {
        dropdown.addOption(index.toString(), picker.name);
      });
      dropdown.setValue(settings.pickerIndex.toString());
      dropdown.onChange(async (pickerIndexString) => {
        const chosenPickerIndex = parseInt(pickerIndexString);
        console.log("New picker mode", this.plugin.pickers[chosenPickerIndex].name);
        settings.pickerIndex = chosenPickerIndex;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian3.Setting(containerEl).setName("Notes").setHeading();
    new import_obsidian3.Setting(containerEl).setName("Note filter sets").setHeading().setDesc(`Add, rename and delete filter sets here`);
    createSettingsNoteFilterSets(containerEl, this.plugin.settings.noteFilterSets, async (sets) => {
      this.plugin.settings.noteFilterSets = sets;
      await this.plugin.saveSettings();
    }, () => {
      this.hide();
      this.plugin.createFilterSetCommands();
      this.display();
    });
    new import_obsidian3.Setting(containerEl).setName("Folders").setHeading();
    new import_obsidian3.Setting(containerEl).setName("Folder filter sets").setHeading().setDesc(`Add, rename and delete filter sets here`);
    createSettingsFolderFilterSets(containerEl, this.plugin.settings.folderFilterSets, async (sets) => {
      this.plugin.settings.folderFilterSets = sets;
      await this.plugin.saveSettings();
    }, () => {
      this.hide();
      this.display();
    });
  }
};
function addFilterSetHeader(containerEl, header, description = "", deletable = true, renamable = true, validateSetName, saveName, deleteSet) {
  const filterSetHeader = new import_obsidian3.Setting(containerEl).setName(header).setHeading().setDesc(description);
  if (renamable) {
    filterSetHeader.addExtraButton((btn) => {
      btn.setIcon("pencil").onClick(async () => {
        const newName = await GenericInputPrompt.Prompt(this.app, "New filter set name", void 0, header, true, validateSetName);
        const newNameFormatted = newName.trim();
        if (!newNameFormatted) {
          new import_obsidian3.Notice("Error: Filter Set Name cannot be blank");
          return;
        }
        await saveName(newNameFormatted);
      });
    });
  }
  if (deletable) {
    filterSetHeader.addExtraButton((btn) => {
      btn.setIcon("trash-2").onClick(async () => {
        if (await BoolInputPrompt.Prompt(this.app, `Delete ${header}?`)) {
          await deleteSet();
        }
      });
    });
  }
}
function createSettingsNoteFilterSets(containerEl, filterSets, saveFilterSets, refreshDisplay) {
  filterSets.forEach((filterSet, i) => {
    createNoteFilterSetInputs(containerEl, filterSet, "", true, true, (text, notify) => {
      const nameNotChanged = text === filterSet.name;
      if (nameNotChanged)
        return true;
      const nameUnique = !filterSets.some((set) => set.name === text.trim());
      const nameHasCharacters = text.trim().length > 0;
      if (!nameUnique && notify)
        new import_obsidian3.Notice("Error: Filter Set Name must be unique");
      if (!nameHasCharacters && notify)
        new import_obsidian3.Notice("Error: Filter Set Name cannot be blank");
      return nameUnique && nameHasCharacters;
    }, async (set) => {
      if (!set) {
        filterSets.splice(i, 1);
        await saveFilterSets(filterSets);
        refreshDisplay();
      } else {
        filterSets[i] = set;
        await saveFilterSets(filterSets);
      }
    }, refreshDisplay);
  });
  new import_obsidian3.Setting(containerEl).addButton((button) => {
    button.setButtonText("Add note filter set");
    button.onClick(async (e) => {
      const newSetName = await GenericInputPrompt.Prompt(this.app, "New filter set name", void 0, void 0, true, (text, notify) => {
        const nameUnique = !filterSets.some((set) => set.name === text.trim());
        if (!nameUnique && notify)
          new import_obsidian3.Notice("Error: Filter Set Name must be unique");
        const nameHasCharacters = text.trim().length > 0;
        if (!nameHasCharacters && notify)
          new import_obsidian3.Notice("Error: Filter Set Name cannot be blank");
        return nameUnique && nameHasCharacters;
      });
      const newNameFormatted = newSetName.trim();
      if (!newNameFormatted) {
        new import_obsidian3.Notice("Error: Filter Set Name cannot be blank");
        return;
      }
      const newFilterSet = {
        ...DEFAULT_NOTE_FILTER_SET,
        name: newNameFormatted
      };
      await saveFilterSets([...filterSets, newFilterSet]);
      refreshDisplay();
    });
  });
}
function createNoteFilterSetInputs(containerEl, filterSet, description = "", deletable = true, renamable = true, validateSetName, saveSet, refreshDisplay) {
  addFilterSetHeader(containerEl, filterSet.name, description, deletable, renamable, validateSetName, async (name) => {
    filterSet.name = name;
    await saveSet(filterSet);
    refreshDisplay();
  }, () => {
    saveSet(null);
  });
  new import_obsidian3.Setting(containerEl).setName("Include path name").addText((text) => {
    text.setValue(filterSet.includePathName).onChange(async (v) => {
      filterSet.includePathName = v.trim();
      await saveSet(filterSet);
    });
  });
  new import_obsidian3.Setting(containerEl).setName("Exclude path name").addText((text) => {
    text.setValue(filterSet.excludePathName).onChange(async (v) => {
      filterSet.excludePathName = v.trim();
      await saveSet(filterSet);
    });
  });
  new import_obsidian3.Setting(containerEl).setName("Include note name").addText((text) => {
    text.setValue(filterSet.includeNoteName).onChange(async (v) => {
      filterSet.includeNoteName = v.trim();
      await saveSet(filterSet);
    });
  });
  new import_obsidian3.Setting(containerEl).setName("Exclude note name").addText((text) => {
    text.setValue(filterSet.excludeNoteName).onChange(async (v) => {
      filterSet.excludeNoteName = v.trim();
      await saveSet(filterSet);
    });
  });
  new import_obsidian3.Setting(containerEl).setName("Include tags").addText((text) => {
    text.setPlaceholder("#Tag1, #Tag2, #Tag3").setValue(filterSet.includeTags).onChange(async (v) => {
      filterSet.includeTags = v.trim();
      await saveSet(filterSet);
    });
  });
  new import_obsidian3.Setting(containerEl).setName("Exclude tags").addText((text) => {
    text.setPlaceholder("#Tag1, #Tag2, #Tag3").setValue(filterSet.excludeTags).onChange(async (v) => {
      filterSet.excludeTags = v.trim();
      await saveSet(filterSet);
    });
  });
}
function createSettingsFolderFilterSets(containerEl, filterSets, saveFilterSets, refreshDisplay) {
  filterSets.forEach((filterSet, i) => {
    createFolderFilterSetInputs(containerEl, filterSet, "", true, true, (text, notify) => {
      const nameUnique = !filterSets.some((set) => set.name === text.trim());
      if (!nameUnique && notify)
        new import_obsidian3.Notice("Error: Filter Set Name must be unique");
      const nameHasCharacters = text.trim().length > 0;
      if (!nameHasCharacters && notify)
        new import_obsidian3.Notice("Error: Filter Set Name cannot be blank");
      return nameUnique && nameHasCharacters;
    }, async (set) => {
      if (!set) {
        filterSets.splice(i, 1);
        await saveFilterSets(filterSets);
        refreshDisplay();
      } else {
        filterSets[i] = set;
        await saveFilterSets(filterSets);
      }
    }, refreshDisplay);
  });
  new import_obsidian3.Setting(containerEl).addButton((button) => {
    button.setButtonText("Add folder filter set");
    button.onClick(async (e) => {
      const newSetName = await GenericInputPrompt.Prompt(this.app, "New filter set name", void 0, void 0, true, (text, notify) => {
        const nameHasCharacters = text.trim().length > 0;
        if (!nameHasCharacters && notify)
          new import_obsidian3.Notice("Error: Filter Set Name cannot be blank");
        return nameHasCharacters;
      });
      const newNameFormatted = newSetName.trim();
      if (!newNameFormatted) {
        new import_obsidian3.Notice("Error: Filter Set Name cannot be blank");
        return;
      }
      const newFilterSet = {
        ...DEFAULT_FOLDER_FILTER_SET,
        name: newNameFormatted
      };
      await saveFilterSets([...filterSets, newFilterSet]);
      refreshDisplay();
    });
  });
}
function createFolderFilterSetInputs(containerEl, filterSet, description = "", deletable = true, renamable = true, validateSetName, saveSet, refreshDisplay) {
  addFilterSetHeader(containerEl, filterSet.name, description, deletable, renamable, validateSetName, async (name) => {
    filterSet.name = name;
    await saveSet(filterSet);
    refreshDisplay();
  }, () => {
    saveSet(null);
  });
  new import_obsidian3.Setting(containerEl).setName("Root folder").addText((text) => {
    text.setPlaceholder("/").setValue(filterSet.rootFolder).onChange(async (v) => {
      filterSet.rootFolder = v.trim() || "/";
      await saveSet(filterSet);
    });
  });
  new import_obsidian3.Setting(containerEl).setName("Include folder name").addText((text) => {
    text.setValue(filterSet.includeFolderName).onChange(async (v) => {
      filterSet.includeFolderName = v.trim();
      await saveSet(filterSet);
    });
  });
  new import_obsidian3.Setting(containerEl).setName("Exclude folder name").addText((text) => {
    text.setValue(filterSet.excludeFolderName).onChange(async (v) => {
      filterSet.excludeFolderName = v.trim();
      await saveSet(filterSet);
    });
  });
  new import_obsidian3.Setting(containerEl).setName("Include path name").addText((text) => {
    text.setValue(filterSet.includePathName).onChange(async (v) => {
      filterSet.includePathName = v.trim();
      await saveSet(filterSet);
    });
  });
  new import_obsidian3.Setting(containerEl).setName("Exclude path name").addText((text) => {
    text.setValue(filterSet.excludePathName).onChange(async (v) => {
      filterSet.excludePathName = v.trim();
      await saveSet(filterSet);
    });
  });
  new import_obsidian3.Setting(containerEl).setDesc("The depth of folders to search down to and should folders above the target depth be shown").addToggle((toggle) => {
    toggle.setTooltip("Include folders above the target depth");
    toggle.setValue(filterSet.includeParents);
    toggle.onChange(async (v) => {
      filterSet.includeParents = v;
      await saveSet(filterSet);
    });
  }).addText((text) => {
    text.setValue((filterSet.depth || "").toString());
    text.setPlaceholder("1");
    text.onChange(async (v) => {
      const depth = parseInt(v);
      if (!depth) {
        new import_obsidian3.Notice("Error: depth must be an number");
        return;
      }
      filterSet.depth = depth || 1;
      await saveSet(filterSet);
    });
  });
}

// src/pickers.ts
var import_obsidian4 = require("obsidian");
var flatPicker = {
  name: "flat",
  description: `Flattens the list of notes. Shows notes as "first_different_folder_name/note_name`,
  pick: (app2, notes, callback) => {
    if (notes.length === 0)
      return;
    if (notes.length === 1)
      return callback(notes[0]);
    new FlatSuggestModal(app2, notes, callback).open();
  }
};
var FlatSuggestModal = class extends import_obsidian4.FuzzySuggestModal {
  constructor(app2, items, callback) {
    super(app2);
    this.items = items;
    this.callback = callback;
    const splitPaths = items.map((i) => i.path.split("/"));
    this.allPathsSameLength = splitPaths.every((path) => path.length === splitPaths[0].length);
    const minLength = Math.min(...splitPaths.map((path) => path.length));
    const firstDifferentFolderIndex = [...Array(minLength).keys()].findIndex((i) => !splitPaths.every((path) => path[i] === splitPaths[0][i]));
    this.firstDifferentFolderIndex = firstDifferentFolderIndex === -1 ? 0 : firstDifferentFolderIndex;
  }
  getItems() {
    return this.items;
  }
  getItemText(item) {
    var _a;
    const splitPath = item.path.split(/[\\/]/g);
    const contextFolderIndex = this.firstDifferentFolderIndex === splitPath.length - 1 ? this.firstDifferentFolderIndex - 1 : this.firstDifferentFolderIndex;
    const contextFolder = this.allPathsSameLength ? splitPath[contextFolderIndex] : splitPath.at(-2);
    const entityName = (_a = splitPath.at(-1)) == null ? void 0 : _a.replace(/\.md$/gi, "");
    return `${contextFolder || ""}/ ${entityName}`;
  }
  onChooseItem(item, evt) {
    this.callback(item);
  }
};
var recursivePicker = {
  name: "recursive",
  description: "Chose a folder and then between any subfolders (if required)",
  pick: (app2, notes, callback) => {
    if (notes.length === 0)
      return;
    if (notes.length === 1)
      return callback(notes[0]);
    let folders, depth = 1;
    do {
      folders = [...new Set(notes.map((n) => n.path.split("/").slice(0, depth).join("/")))];
      depth++;
    } while (folders.length === 1);
    if (depth === 1) {
      new FlatSuggestModal(app2, notes, (f) => {
        callback(f);
      }).open();
    } else {
      new RecurSuggestModal(app2, folders, (p) => {
        const folderNotes = notes.filter((n) => n.path.startsWith(p));
        recursivePicker.pick(app2, folderNotes, callback);
      }).open();
    }
  }
};
var RecurSuggestModal = class extends import_obsidian4.FuzzySuggestModal {
  constructor(app2, items, callback) {
    super(app2);
    this.items = items;
    this.callback = callback;
  }
  getItems() {
    return this.items;
  }
  getItemText(item) {
    return item;
  }
  onChooseItem(item, evt) {
    this.callback(item);
  }
};
var pickers = [flatPicker, recursivePicker];

// src/main.ts
var FilterSetSuggestModal = class extends import_obsidian5.FuzzySuggestModal {
  constructor(app2, items, callback) {
    super(app2);
    this.items = items;
    this.callback = callback;
  }
  getItems() {
    return this.items;
  }
  getItemText(item) {
    return `${item.name}`;
  }
  onChooseItem(item, evt) {
    this.callback(item);
  }
};
async function choseFilterSet(FilterSets) {
  return new Promise((resolve, rejects) => {
    new FilterSetSuggestModal(this.app, FilterSets, resolve).open();
  });
}
var FnOPlugin = class extends import_obsidian5.Plugin {
  constructor() {
    super(...arguments);
    this.pickers = pickers;
  }
  async onload() {
    await this.loadSettings();
    this.api_getNote = this.getNote, this.api_getFolder = this.getFolder, this.api_createSettingsNoteFilterSets = createSettingsNoteFilterSets;
    this.api_createNoteFilterSetInputs = createNoteFilterSetInputs;
    this.api_createSettingsFolderFilterSets = createSettingsFolderFilterSets;
    this.api_createFolderFilterSetInputs = createFolderFilterSetInputs;
    this.api_getListOfNoteFilterSets = () => this.settings.noteFilterSets;
    this.api_getListOfFolderFilterSets = () => this.settings.folderFilterSets;
    this.addCommand({
      id: "pick-note",
      name: "Pick note",
      callback: async () => {
        if (this.settings.noteFilterSets.length == 0) {
          new import_obsidian5.Notice("Error: no note filter sets defined");
          return;
        }
        const noteFilterSet = this.settings.noteFilterSets.length === 1 ? this.settings.noteFilterSets[0] : await choseFilterSet(this.settings.noteFilterSets);
        const note = await this.getNote(noteFilterSet);
        this.app.workspace.getLeaf(true).openFile(note);
      }
    });
    this.addCommand({
      id: "pick-folder",
      name: "Pick folder",
      callback: async () => {
        if (this.settings.folderFilterSets.length == 0) {
          new import_obsidian5.Notice("Error: no folder filter sets defined");
          return;
        }
        const folderFilterSet = this.settings.folderFilterSets.length === 1 ? this.settings.folderFilterSets[0] : await choseFilterSet(this.settings.folderFilterSets);
        const folder = await this.getFolder(folderFilterSet);
        console.log(folder);
      }
    });
    this.createFilterSetCommands();
    this.addSettingTab(new FNOSettingTab(this.app, this));
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  getNote(noteFilterSet = DEFAULT_NOTE_FILTER_SET) {
    return new Promise((resolve, reject) => {
      var _a;
      if (noteFilterSet === "")
        noteFilterSet = DEFAULT_NOTE_FILTER_SET;
      else if (typeof noteFilterSet === "string") {
        const noteFilterSetOfName = this.settings.noteFilterSets.find((set) => set.name === noteFilterSet);
        if (!noteFilterSetOfName) {
          new import_obsidian5.Notice(`Error: Note Filter Set "${noteFilterSet}" does not exist`);
          return reject(null);
        }
        noteFilterSet = noteFilterSetOfName;
      }
      const filteredNotes = filterNoteList(noteFilterSet, this.app.vault.getFiles());
      if (filteredNotes.length === 0) {
        new import_obsidian5.Notice(`Error: No notes match filter set "${noteFilterSet.name}"`);
        return reject(`No notes match filter set "${noteFilterSet.name}"`);
      }
      if (filteredNotes.length === 1) {
        return resolve(filteredNotes[0]);
      }
      const nearestNotesInSet = getNearestNotesInSet(((_a = this.app.workspace.getActiveFile()) == null ? void 0 : _a.parent) || null, noteFilterSet);
      for (let note of nearestNotesInSet) {
        filteredNotes.remove(note);
        filteredNotes.unshift(note);
      }
      this.pickers[this.settings.pickerIndex].pick(this.app, filteredNotes, (file) => resolve(file));
    });
  }
  getFolder(folderFilterSet = DEFAULT_FOLDER_FILTER_SET) {
    return new Promise((resolve, reject) => {
      if (folderFilterSet === "")
        folderFilterSet = DEFAULT_FOLDER_FILTER_SET;
      else if (typeof folderFilterSet === "string") {
        const folderFilterSetOfName = this.settings.folderFilterSets.find((set) => set.name === folderFilterSet);
        if (!folderFilterSetOfName) {
          new import_obsidian5.Notice(`Error: Folder Filter Set "${folderFilterSet}" does not exist`);
          return reject(null);
        }
        folderFilterSet = folderFilterSetOfName;
      }
      const { includeParents, depth, rootFolder } = folderFilterSet;
      let folders = [];
      function appendFoldersStartingFrom(folder, currentDepth) {
        if (includeParents || currentDepth === depth)
          folders.push(folder);
        if (currentDepth <= depth) {
          folder.children.flatMap((f) => f instanceof import_obsidian5.TFolder ? appendFoldersStartingFrom(f, currentDepth + 1) : []);
        }
      }
      const rootFolderInstance = this.app.vault.getAbstractFileByPath(rootFolder);
      if (!(rootFolderInstance instanceof import_obsidian5.TFolder)) {
        throw new Error(`Root folder ${rootFolder} does not exist`);
      }
      appendFoldersStartingFrom(rootFolderInstance, 0);
      const filteredFolders = filterFolderList(folderFilterSet, folders);
      if (filteredFolders.length === 0) {
        new import_obsidian5.Notice(`Error: No folders match filter set "${folderFilterSet.name}"`);
        return reject(`No folders match filter set "${folderFilterSet.name}"`);
      }
      if (filteredFolders.length === 1) {
        return resolve(filteredFolders[0]);
      }
      this.pickers[this.settings.pickerIndex].pick(this.app, filteredFolders, (folder) => resolve(folder));
    });
  }
  createFilterSetCommands() {
    for (let noteSet of this.settings.noteFilterSets) {
      const normalizedSetName = noteSet.name.toLowerCase().replaceAll(/[^\w\s]/g, "").replace(/\s+/g, " ").replace(/\s/g, "-");
      this.addCommand({
        id: `open-${normalizedSetName}-note`,
        name: `Open ${noteSet.name} Note`,
        callback: async () => {
          const note = await this.getNote(noteSet);
          this.openNote(note);
        }
      });
    }
  }
  openNote(note) {
    if (!note)
      return;
    this.app.workspace.getLeaf(true).openFile(note);
  }
};
function getNearestNotesInSet(parent, noteFilterSet) {
  if (!parent)
    return [];
  const siblings = parent.children;
  if (siblings && siblings[0]) {
    const filteredSiblings = filterNoteList(noteFilterSet, siblings.flatMap((f) => f instanceof import_obsidian5.TFile ? [f] : []));
    if (filteredSiblings.length > 0) {
      filteredSiblings.reverse();
      return filteredSiblings;
    }
    return getNearestNotesInSet(parent.parent, noteFilterSet);
  }
  return [];
}
function getRegexIfValid(str) {
  const regexPattern = /^\/(.*)\/([gimuy]*)$/;
  const match = str.match(regexPattern);
  if (!match) {
    return null;
  }
  const [, pattern, flags] = match;
  try {
    return new RegExp(pattern, flags);
  } catch (e) {
    return null;
  }
}
function filterNoteList(settings, list) {
  if (settings.includePathName) {
    const includePathNameRegExp = getRegexIfValid(settings.includePathName);
    if (includePathNameRegExp) {
      list = list.filter((f) => f.path.match(includePathNameRegExp));
    } else {
      list = list.filter((f) => f.path.includes(settings.includePathName));
    }
  }
  if (settings.includeNoteName) {
    const includeNoteNameRegExp = getRegexIfValid(settings.includeNoteName);
    if (includeNoteNameRegExp) {
      list = list.filter((f) => f.name.match(includeNoteNameRegExp));
    } else {
      list = list.filter((f) => f.name.includes(settings.includeNoteName));
    }
  }
  if (settings.excludePathName) {
    const excludePathNameRegExp = getRegexIfValid(settings.excludePathName);
    if (excludePathNameRegExp) {
      list = list.filter((f) => !f.path.match(excludePathNameRegExp));
    } else {
      list = list.filter((f) => !f.path.includes(settings.excludePathName));
    }
  }
  if (settings.excludeNoteName) {
    const excludeNoteNameRegExp = getRegexIfValid(settings.excludeNoteName);
    if (excludeNoteNameRegExp) {
      list = list.filter((f) => !f.name.match(settings.excludeNoteName));
    } else {
      list = list.filter((f) => !f.name.includes(settings.excludeNoteName));
    }
  }
  if (settings.includeTags) {
    const includeTagRegExp = getRegexIfValid(settings.includeTags);
    if (includeTagRegExp) {
      list = list.filter((f) => {
        var _a;
        const fCache = app.metadataCache.getFileCache(f);
        if (!fCache)
          return false;
        return (_a = (0, import_obsidian5.getAllTags)(fCache)) == null ? void 0 : _a.some((t) => t.match(includeTagRegExp));
      });
    } else {
      const includeTags = settings.includeTags.split(/\s*,\s*/);
      list = list.filter((f) => {
        const fCache = app.metadataCache.getFileCache(f);
        if (!fCache)
          return false;
        const fTags = (0, import_obsidian5.getAllTags)(fCache);
        if (!fTags)
          return false;
        return includeTags.every((it) => fTags.some((t) => t.startsWith(it)));
      });
    }
  }
  if (settings.excludeTags) {
    const excludeTagRegExp = getRegexIfValid(settings.excludeTags);
    if (excludeTagRegExp) {
      list = list.filter((f) => {
        var _a;
        const fCache = app.metadataCache.getFileCache(f);
        if (!fCache)
          return true;
        return !((_a = (0, import_obsidian5.getAllTags)(fCache)) == null ? void 0 : _a.some((t) => t.match(excludeTagRegExp)));
      });
    } else {
      const excludeTags = settings.excludeTags.split(/\s*,\s*/);
      list = list.filter((f) => {
        const fCache = app.metadataCache.getFileCache(f);
        if (!fCache)
          return true;
        const fTags = (0, import_obsidian5.getAllTags)(fCache);
        if (!fTags)
          return true;
        return !excludeTags.some((et) => fTags.some((t) => t.startsWith(et)));
      });
    }
  }
  return list;
}
function filterFolderList(settings, list) {
  if (settings.includePathName) {
    const includePathNameRegExp = getRegexIfValid(settings.includePathName);
    if (includePathNameRegExp) {
      list = list.filter((f) => f.path.match(includePathNameRegExp));
    } else {
      list = list.filter((f) => f.path.includes(settings.includePathName));
    }
  }
  if (settings.includeFolderName) {
    const includeFolderNameRegExp = getRegexIfValid(settings.includeFolderName);
    if (includeFolderNameRegExp) {
      list = list.filter((f) => f.name.match(includeFolderNameRegExp));
    } else {
      list = list.filter((f) => f.name.includes(settings.includeFolderName));
    }
  }
  if (settings.excludePathName) {
    const excludePathNameRegExp = getRegexIfValid(settings.excludePathName);
    if (excludePathNameRegExp) {
      list = list.filter((f) => !f.path.match(excludePathNameRegExp));
    } else {
      list = list.filter((f) => !f.path.includes(settings.excludePathName));
    }
  }
  if (settings.excludeFolderName) {
    const excludeFolderNameRegExp = getRegexIfValid(settings.excludeFolderName);
    if (excludeFolderNameRegExp) {
      list = list.filter((f) => !f.name.match(excludeFolderNameRegExp));
    } else {
      list = list.filter((f) => !f.name.includes(settings.excludeFolderName));
    }
  }
  return list;
}

/* nosourcemap */